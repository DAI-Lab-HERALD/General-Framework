# Adverarial attack generation

## Setting parameters

For the generation of adversarial attacks according to the underlying paper [Realistic Adversarial Attacks for Robustness Evaluation of Trajectory Prediction Models via Future State Perturbation](https://arxiv.org/abs/2505.06134)  we need to configure a few things. For this, in the [perturbation call, the perturbation dictionary](https://github.com/DAI-Lab-HERALD/General-Framework/tree/main/Framework#datasets) can be extended with the following keys, which fullfill different purposes (the given values are the default values assumed by the Framework if not set):

### Attack hyperparameters
The number of predicted trajectories generated by the attack model to calcualte the gradient on:
```
"num_samples_perturb": 20 
```
Setting the max number of iterations $M$ of the projected gradient descent (PGD):
```
"max_number_iterations": 50
```
The initial "learning" rate $\alpha_{0}$ and its decay rate $\gamma$ employed during PGD ($\alpha_m = \gamma ^{m} \alpha_{0}$):
```
"alpha": 0.01
"gamma": 1
```

### Evaluation ground truth
Setting the type of future ground truth data a model's prediction are compared against for calculating metrics, with three feasible options:
- *'no'* => The unperturbed future data is the ground truth
- *'one'* => The average predicted future on based on the unperturbed data
- *'full'* => The perturbed future recorded after the last iteration of PGD
``` 
"GT_data": 'no'
```

### Attack loss
One can desing a loss function with up to (but at least one) attack losses, which will be minimied during the PGD. A table with the available losses is seen below (in the formulas, the averaging over the $K$ prediction is left out for easier readability).
```
"loss_function_1": 'ADE_Y_GT_Y_Pred_Max'
"loss_function_2": None
```


| Type attack   | First input   | Second input  | Objective     | Formula       | Name framework (str)  | 
| ------------- | ------------- | ------------- | ------------- | ------------- |   -------------       |
| ADE           | $Y_{\text{tar}}$  | $\hat{\tilde{Y}}_{\text{tar}}$ | Maximize distance | $`-\frac{1}{T} {\sum}_{t=1}^{T} \left\| \hat{\tilde{Y}}_{\text{tar}}^{t} - {Y}_{\text{tar}}^{t} \right\|_2`$ | 'ADE_Y_GT_Y_Pred_Max' |
| ADE           | $Y_{\text{tar}}$  | $\hat{\tilde{Y}}_{\text{tar}}$ | Minimize distance | $`\frac{1}{T} {\sum}_{t=1}^{T} \left\| \hat{\tilde{Y}}_{\text{tar}}^{t} - {Y}_{\text{tar}}^{t} \right\|_2`$ | 'ADE_Y_GT_Y_Pred_Min' |
| FDE           | $Y_{\text{tar}}$  | $\hat{\tilde{Y}}_{\text{tar}}$ | Maximize distance | $`- \left\| \hat{\tilde{Y}}_{\text{tar}}^{T} - {Y}_{\text{tar}}^{T} \right\|_2`$ | 'FDE_Y_GT_Y_Pred_Max' |
| FDE           | $Y_{\text{tar}}$  | $\hat{\tilde{Y}}_{\text{tar}}$ | Minimize distance | $` \left\| \hat{\tilde{Y}}_{\text{tar}}^{T} - {Y}_{\text{tar}}^{T} \right\|_2`$ | 'FDE_Y_GT_Y_Pred_Min' |
| ADE           | $\tilde{Y}_{\text{tar}}$  | $\hat{\tilde{Y}}_{\text{tar}}$ | Maximize distance | $`-\frac{1}{T} {\sum}_{t=1}^{T} \left\| \hat{\tilde{Y}}_{\text{tar}}^{t} - \tilde{Y}_{\text{tar}}^{t} \right\|_2`$ | 'ADE_Y_Perturb_Y_Pred_Max' |
| ADE           | $\tilde{Y}_{\text{tar}}$  | $\hat{\tilde{Y}}_{\text{tar}}$ | Minimize distance | $`\frac{1}{T} {\sum}_{t=1}^{T} \left\| \hat{\tilde{Y}}_{\text{tar}}^{t} - \tilde{Y}_{\text{tar}}^{t} \right\|_2`$ | 'ADE_Y_Perturb_Y_Pred_Min' |
| FDE           | $\tilde{Y}_{\text{tar}}$  | $\hat{\tilde{Y}}_{\text{tar}}$ | Maximize distance | $`- \left\| \hat{\tilde{Y}}_{\text{tar}}^{T} - \tilde{Y}_{\text{tar}}^{T} \right\|_2`$ | 'FDE_Y_Perturb_Y_Pred_Max' |
| FDE           | $\tilde{Y}_{\text{tar}}$  | $\hat{\tilde{Y}}_{\text{tar}}$ | Minimize distance | $` \left\| \hat{\tilde{Y}}_{\text{tar}}^{T} - \tilde{Y}_{\text{tar}}^{T} \right\|_2`$ | 'FDE_Y_Perturb_Y_Pred_Min' |
| ADE           | $\tilde{Y}_{\text{tar}}$  | ${Y}_{\text{tar}}$ | Maximize distance | $`-\frac{1}{T} {\sum}_{t=1}^{T} \left\| {Y}_{\text{tar}}^{t} - \tilde{Y}_{\text{tar}}^{t} \right\|_2`$ | 'ADE_Y_Perturb_Y_GT_Max' |
| ADE           | $\tilde{Y}_{\text{tar}}$  | ${Y}_{\text{tar}}$ | Minimize distance | $`\frac{1}{T} {\sum}_{t=1}^{T} \left\| {Y}_{\text{tar}}^{t} - \tilde{Y}_{\text{tar}}^{t} \right\|_2`$ | 'ADE_Y_Perturb_Y_GT_Min' |
| FDE           | $\tilde{Y}_{\text{tar}}$  | ${Y}_{\text{tar}}$ | Maximize distance | $`- \left\| {Y}_{\text{tar}}^{T} - \tilde{Y}_{\text{tar}}^{T} \right\|_2`$ | 'FDE_Y_Perturb_Y_GT_Max' |
| FDE           | $\tilde{Y}_{\text{tar}}$  | ${Y}_{\text{tar}}$ | Minimize distance | $` \left\| {Y}_{\text{tar}}^{T} - \tilde{Y}_{\text{tar}}^{T} \right\|_2`$ | 'FDE_Y_Perturb_Y_GT_Min' |
| ADE           | $\hat{Y}_{\text{tar}}$  | $\tilde{Y}_{\text{tar}}$ | Maximize distance | $`-\frac{1}{T} {\sum}_{t=1}^{T} \left\| \tilde{Y}_{\text{tar}}^{t} - \hat{Y}_{\text{tar}}^{t} \right\|_2`$ | 'ADE_Y_pred_iteration_1_and_Y_Perturb_Max' |
| ADE           | $\hat{Y}_{\text{tar}}$  | $\tilde{Y}_{\text{tar}}$ | Minimize distance | $`\frac{1}{T} {\sum}_{t=1}^{T} \left\| \tilde{Y}_{\text{tar}}^{t} - \hat{Y}_\text{tar}^{t} \right\|_2`$ | 'ADE_Y_pred_iteration_1_and_Y_Perturb_Min' |
| FDE           | $\hat{Y}_{\text{tar}}$  | $\tilde{Y}_{\text{tar}}$ | Maximize distance | $`-\left\| \tilde{Y}_{\text{tar}}^{T} - \hat{Y}_{\text{tar}}^{T} \right\|_2`$ | 'FDE_Y_pred_iteration_1_and_Y_Perturb_Max' |
| FDE           | $\hat{Y}_{\text{tar}}$  | $\tilde{Y}_{\text{tar}}$ | Minimize distance | $`\left\| \tilde{Y}_{\text{tar}}^{T} - \hat{Y}_{\text{tar}}^{T} \right\|_2`$ | 'FDE_Y_pred_iteration_1_and_Y_Perturb_Min' |
| ADE           | $\hat{\tilde{Y}}_{\text{tar}}$  | $\hat{Y}_{\text{tar}}$ | Maximize distance | $`-\frac{1}{T} {\sum}_{t=1}^{T} \left\| \hat{Y}_{\text{tar}}^{t} - \hat{\tilde{Y}}_{\text{tar}}^{t} \right\|_2`$ | 'ADE_Y_pred_and_Y_pred_iteration_1_Max' |
| ADE           | $\hat{\tilde{Y}}_{\text{tar}}$  | $\hat{Y}_{\text{tar}}$ | Minimize distance | $`\frac{1}{T} {\sum}_{t=1}^{T} \left\| \hat{Y}_{\text{tar}}^{t} - \hat{\tilde{Y}}_\text{tar}^{t} \right\|_2`$ | 'ADE_Y_pred_and_Y_pred_iteration_1_Min' |
| FDE           | $\hat{\tilde{Y}}_{\text{tar}}$  | $\hat{Y}_{\text{tar}}$ | Maximize distance | $`- \left\| \hat{Y}_{\text{tar}}^{T} - \hat{\tilde{Y}}_{\text{tar}}^{T} \right\|_2`$ | 'ADE_Y_pred_and_Y_pred_iteration_1_Max' |
| FDE           | $\hat{\tilde{Y}}_{\text{tar}}$  | $\hat{Y}_{\text{tar}}$ | Minimize distance | $` \left\| \hat{Y}_{\text{tar}}^{T} - \hat{\tilde{Y}}_\text{tar}^{T} \right\|_2`$ | 'ADE_Y_pred_and_Y_pred_iteration_1_Min' |
| Collision     | $\hat{\tilde{Y}}_{\text{tar}}$  | ${Y}_{\text{ego}}$ | Minimize smallest distance | $`\min_{t \in \{1, \ldots, T\}} \left\| \hat{\tilde{Y}}_{\text{tar}}^{t} - Y_{\text{ego}}^{t} \right\|_2`$ | 'Collision_Y_pred_tar_Y_GT_ego' |
| Collision     | $\tilde{Y}_{\text{tar}}$  | ${Y}_{\text{ego}}$ | Minimize smallest distance | $`\min_{t \in \{1, \ldots, T\}} \left\| \tilde{Y}_{\text{tar}}^{t} - Y_{\text{ego}}^{t} \right\|_2`$ | 'Collision_Y_Perturb_tar_Y_GT_ego' |

### Barrier function
![image](https://github.com/DAI-Lab-HERALD/General-Framework/blob/main/Framework/Perturbation_methods/Adversarial_classes/animated_gif/Regularization_with_third_term-1.png)
One can also select a barrier function to limit the potential perturbations for both the past and the future data. For both, there are three options, shown in the Figure above (*'Time_specific'* (A), *'Trajectory_specific'* (B), *'Time_Trajectory_specific'* (C)). Alternative, if no barrier is desired, *None* can be set as well.
```
"barrier_function_past": None
"barrier_function_future": None
```

For each barrier, a distance threshold $d_{\max}$ can be selected:
```
"distance_threshold_past": 1
"distance_threshold_future": 1
```

Addittionally, we can set a weightfactor $\lambda > 1$, where the barrier function is multiplied with $\frac{1}{\ln \lambda}$ (i.e., higher values leave less impact for this function):
```
"log_value_past": 1.5
"log_value_future": 1.5
```

The specific equations underlting the calculatin of the barrier function loss can be found in [Section IV.C of the underlying paper](**TODO: Add citation here**).



## Attack examples
Below depicted are some examples of the attacks used in the underlying paper.
### Nominal setting
![image](https://github.com/DAI-Lab-HERALD/General-Framework/blob/main/Framework/Perturbation_methods/Adversarial_classes/animated_gif/Animation_basic.gif)

### ADE/FDE attack
![image](https://github.com/DAI-Lab-HERALD/General-Framework/blob/main/Framework/Perturbation_methods/Adversarial_classes/animated_gif/Animation_ADE.gif)
To create this attack set:
```
self.loss_function_1 = 'ADE_Y_GT_Y_Pred_Max' or 'FDE_Y_GT_Y_Pred_Max'
self.loss_function_2 = None 
```
```
 self.barrier_function_past = 'Time_specific', 'Trajectory_specific' or 'Time_Trajectory_specific' 
 self.barrier_function_future = None
```
### Collision attack
![image](https://github.com/DAI-Lab-HERALD/General-Framework/blob/main/Framework/Perturbation_methods/Adversarial_classes/animated_gif/Animation_Collision.gif)
To create this attack set:
```
self.loss_function_1 = 'Collision_Y_pred_tar_Y_GT_ego'
self.loss_function_2 = None 
```
```
 self.barrier_function_past = 'Time_specific', 'Trajectory_specific' or 'Time_Trajectory_specific' 
 self.barrier_function_future = None
```
### Max ADE/FDE attack
![image](https://github.com/DAI-Lab-HERALD/General-Framework/blob/main/Framework/Perturbation_methods/Adversarial_classes/animated_gif/Animation_max_ADE.gif)
To create this attack set:
```
self.loss_function_1 = 'ADE_Y_Perturb_Y_Pred_Max' or 'FDE_Y_Perturb_Y_Pred_Max'
self.loss_function_2 = None 
```
```
 self.barrier_function_past = 'Time_specific', 'Trajectory_specific' or'Time_Trajectory_specific' 
 self.barrier_function_future = 'Time_specific', 'Trajectory_specific' or 'Time_Trajectory_specific'
```
### Fake Collision attack
![image](https://github.com/DAI-Lab-HERALD/General-Framework/blob/main/Framework/Perturbation_methods/Adversarial_classes/animated_gif/Animation_Fake_collision.gif)
To create this attack set:
```
self.loss_function_1 = 'Collision_Y_pred_tar_Y_GT_ego'
self.loss_function_2 = 'Y_Perturb' 
```
```
 self.barrier_function_past = 'Time_specific', 'Trajectory_specific' or 'Time_Trajectory_specific' 
 self.barrier_function_future = 'Time_specific', 'Trajectory_specific' or 'Time_Trajectory_specific'
```
### Hide Collision attack
![image](https://github.com/DAI-Lab-HERALD/General-Framework/blob/main/Framework/Perturbation_methods/Adversarial_classes/animated_gif/Animation_Hide_collision.gif)
To create this attack set:
```
self.loss_function_1 = 'Collision_Y_Perturb_tar_Y_GT_ego'
self.loss_function_2 = 'ADE_Y_pred_and_Y_pred_iteration_1_Min'
```
```
 self.barrier_function_past = 'Time_specific', 'Trajectory_specific', 'Time_Trajectory_specific' 
 self.barrier_function_future = None
```

## Adding new attack functions
[Modify here](https://github.com/DAI-Lab-HERALD/General-Framework/blob/main/Framework/Perturbation_methods/Adversarial_classes/loss.py)
### Attack
1.  In the Loss class, create a new function using the following structure. Use the inputs: X, X_new, Y, Y_new, Y_Pred, Y_Pred_iter_1, barrier_data, tar_agent, and ego_agent. Note that tar_agent and ego_agent are the indices of the target and ego agents, respectively.
```
def name_of_loss_function(X, X_new, Y, Y_new, Y_Pred, Y_Pred_iter_1, barrier_data, tar_agent, ego_agent):
    return loss_function
```
2. Create a new class with the following structure. The sign depends on the specific objective of the attack.
```
class NameOfAttack(LossFunction):
    def calculate_loss(self, X, X_new, Y, Y_new, Pred_t, Pred_iter_1, tar_agent, ego_agent):
        return +/- name_of_loss_function(X, X_new, Y, Y_new, Pred_t, Pred_iter_1, tar_agent, ego_agent)
```
3. Finally, define the name in the get_name function. If you want to use future perturbation, ensure the string includes 'Y_Perturb'.
```
elif loss_function == 'name_of_attack':
    return NameOfAttack()
```

### Regularization
1.  In the Loss class, create a new function using the following structure. Use the inputs: X, X_new, Y, Y_new, Y_Pred, Y_Pred_iter_1, barrier_data, tar_agent, and ego_agent. Note that tar_agent and ego_agent are the indices of the target and ego agents, respectively.
```
def name_of_regularization_function(X, X_new, Y, Y_new, Y_Pred, Y_Pred_iter_1, barrier_data, tar_agent, ego_agent):
    return regularization_function
```
2. Create a new class with the following structure. The sign depends on the specific objective of the regularization.
```
class NameOfRegularization(LossFunction):
    def calculate_barrier(self, X, X_new, Y, Y_new, Pred_t, Pred_iter_1, tar_agent, ego_agent):
        return +/- name_of_regularization_function(X, X_new, Y, Y_new, Pred_t, Pred_iter_1, tar_agent, ego_agent)
``` 
3. Finally, define the name in the barrier_function_name_past_states function or the barrier_function_name_future_states function, depending on which states the regularization is needed for.
```
elif barrier_function == 'name_of_regularization':
    return NameOfRegularization()
```
